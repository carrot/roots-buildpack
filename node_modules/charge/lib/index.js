// Generated by CoffeeScript 1.7.0
(function() {
  var WebSocket, charge, connect, extend, fs, http, initialize_websockets, m, parse_options, path, remove, send, start, uuid;

  fs = require('fs');

  path = require('path');

  http = require('http');

  extend = require('lodash.assign');

  remove = require('lodash.remove');

  connect = require('connect');

  WebSocket = require('faye-websocket');

  uuid = require('node-uuid');

  m = require('./middleware');


  /**
   * The main function, given a root and options, returns a decorated connect
   * instance pre-loaded with selected middleware.
   *
   * @param  {String} root - the root of the project to be served
   * @param  {*} opts - string, object, or undefined, described below
   * @return {Function} an instance of connect
   */

  module.exports = charge = function(root, opts) {
    var app;
    root = path.resolve(root);
    opts = parse_options(root, opts);
    if (opts.root) {
      root = path.resolve(opts.root);
    }
    if (typeof opts.websockets === 'undefined') {
      opts.websockets = true;
    }
    if (opts.gzip === true) {
      opts.gzip = {
        threshold: 0
      };
    }
    if (opts.write) {
      opts.gzip = false;
    }
    if (typeof opts.log === 'undefined') {
      opts.log = 'dev';
    }
    app = connect();
    if (opts.clean_urls) {
      app.use(m.hygienist(root));
    }
    if (opts.routes) {
      app.use(m.pathologist(opts.routes));
    }
    if (opts.exclude) {
      app.use(m.escapist(opts.exclude));
    }
    if (opts.auth) {
      app.use(m.publicist(opts.auth));
    }
    if (opts.cache_control) {
      app.use(m.archivist(opts.cache_control));
    }
    if (opts.gzip) {
      app.use(m.minimist(opts.gzip));
    }
    if (opts.write) {
      app.use(m.journalist(opts.write));
    }
    if (opts.log) {
      app.use(m.columnist(opts.log));
    }
    if (opts.url) {
      app.use(opts.url, m.alchemist(root));
    } else {
      app.use(m.alchemist(root));
    }
    app.use(m.apologist(root, opts.error_page));
    extend(app, {
      start: start.bind(app, opts.websockets)
    });
    return app;
  };


  /**
   * Starts a server using the charge instance. Accepts an optional port
   * and a callback, port defaults to 1111. Also initializes websockets and
   * keeps track of open sockets while the server is running.
   *
   * @param  {Boolean} ws_enabled - private bound variable, ignore
   * @param  {Integer} port - port to start the server on, defaults to 1111
   * @param  {Function} cb - callback, called when server has started
   * @return {Object} node http server instance
   */

  start = function(ws_enabled, port, cb) {
    if (port == null) {
      port = 1111;
    }
    if (typeof port === 'function') {
      cb = port;
      port = 1111;
    }
    this.server = http.createServer(this).listen(port, cb);
    extend(this.server, {
      send: send.bind(this.server, ws_enabled)
    });
    if (ws_enabled) {
      initialize_websockets.call(this.server);
    }
    return this.server;
  };


  /**
   * Send a message to the client via websockets.
   *
   * @param  {*} msg - the message you want to send. preferably string or object
   * @param  {Object} opts - additional options passed to faye-websockets
   */

  send = function(ws_enabled, msg, opts) {
    var sock, _i, _len, _ref, _results;
    if (!ws_enabled) {
      throw new Error('websockets disabled');
    }
    if (typeof msg === 'object') {
      msg = JSON.stringify(msg);
    }
    _ref = this.sockets;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sock = _ref[_i];
      _results.push(sock.send(msg, opts));
    }
    return _results;
  };


  /**
   * The options param can accept a number of different types of input.
   *
   * - A string will be treated as a path to load json config from
   * - An object will be treated as a straight options object
   * - Undefined will try to load from default config paths, default to {}
   *
   * This method takes the direct options arg and parses whatever is given into
   * an object or throws an error if there's an invalid type passed.
   *
   * @private
   * @param  {String} root - charge project root
   * @param  {*} opts - options argument
   * @return {Object} parsed options object
   */

  parse_options = function(root, opts) {
    var exists, load_json;
    exists = function(name) {
      return fs.existsSync(path.resolve(root, name));
    };
    load_json = function(name) {
      return require(path.resolve(root, name));
    };
    switch (typeof opts) {
      case 'string':
        return load_json(opts);
      case 'object':
        return opts;
      case 'undefined':
        return (function() {
          if (exists('charge.json')) {
            return load_json('charge.json');
          }
          if (exists('superstatic.json')) {
            return load_json('superstatic.json');
          }
          if (exists('divshot.json')) {
            return load_json('divshot.json');
          }
          return {};
        })();
      default:
        throw new Error('invalid options');
    }
  };


  /**
   * Initialize websockets listener and keep track of connections. Emits events
   * on initial connection and on message from the client.
   *
   * @private
   */

  initialize_websockets = function() {
    this.sockets = [];
    return this.on('upgrade', (function(_this) {
      return function(req, socket, body) {
        var ws;
        if (!WebSocket.isWebSocket(req)) {
          return;
        }
        ws = new WebSocket(req, socket, body);
        ws.id = uuid.v1();
        ws.on('open', function(e) {
          _this.sockets.push(ws);
          return _this.emit('client_open', e);
        });
        ws.on('message', _this.emit.bind(_this, 'message'));
        return ws.on('close', function(e) {
          remove(_this.sockets, function(s) {
            return s.id === ws.id;
          });
          return _this.emit('client_close', e);
        });
      };
    })(this));
  };


  /**
   * @exports hygienist
   * @exports escapist
   * @exports archivist
   * @exports alchemist
   * @exports apologist
   * @exports publicist
   * @exports pathologist
   * @exports journalist
   */

  extend(module.exports, m);

}).call(this);
